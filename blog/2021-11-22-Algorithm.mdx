```js title="节流"
function throttle(fn, time = 300) {
  // 先点击生效
  let flag = false;
  return function () {
    if (flag) {
      return;
    }
    flag = true;
    setTimeout(() => {
      fn.call(this, arguments);
      flag = false;
    }, time);
  };
}
```

```js title="防抖"
function debounce(fn, time = 300) {
  // 后执行
  let timer;
  return function () {
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.call(this, arguments);
    }, time);
  };
}
```

```js title="深拷贝"
function clone(target, map = new Map()) {
  if (typeof target === "object") {
    let obj = Array.isArray(target) ? [] : {};

    if (map.get(target)) {
      return map.get(target);
    }

    map.set(target, obj);

    for (const key in target) {
      obj[key] = clone(target[key], map);
    }
    return obj;
  } else {
    return target;
  }
}
```

```js title="三数之和"
function threeSum(nums) {
  nums = [-1, 0, 1, 2, -1, -4];
  let res = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i - 1]) continue;

    let left = i + 1;
    let right = nums.length - 1;
    let target = -nums[i];

    while (left < right) {
      if (nums[left] + nums[right] === target) {
        res.push([nums[left], -target, nums[right]]);
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        left++;
        right--;
      } else if (nums[left] + nums[right] > target) {
        right--;
      } else {
        left++;
      }
    }
  }

  return res;
}
```

```js title="三数之和 closest"
function threeSumClosest(nums, target) {
  let res = 0;
  let min = Number.MAX_VALUE;
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i - 1]) continue;

    let left = i + 1;
    let right = nums.length - 1;
    let current = nums[i];
    let dist = 0;

    while (left < right) {
      let sum = nums[left] + nums[right] + current;
      dist = Math.abs(sum - target);

      if (dist === 0) {
        return target;
      } else if (sum > target) {
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        right--;
      } else {
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        left++;
      }

      if (min > dist) {
        min = dist;
        res = sum;
      }
    }
  }
  return res;
}
```

```js title="携程手写题"
// 已知如下数组：
// var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
// 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];

function fn(arr) {
  return Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b);
}
fn(arr);
```

```js title="冒泡排序"
// [1,2,3,1,3,54,12,4,1,43,5]
const arr = [1, 2, 3, 1, 3, 54, 12, 4, 1, 43, 5];
for (let i = 0; i < arr.length; i += 1) {
  for (let j = 0; j < arr.length - 1 - i; j += 1) {
    if (arr[j] > arr[j + 1]) {
      let temp = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = temp;
    }
  }
}
```

```js title="柯里化函数"
// curryingAdd(1)(2)
function curryingAdd(x) {
  return function (y) {
    return x + y;
  };
}
curryingAdd(1)(2);
```

**手写 useReducer**

:::tip

需要注意的点

- 1. reducer 函数和初始的状态值是用户自定义的
- 2. reducer 函数接受两个参数分别是 state 和 action
- 3. useReducer 函数接收用户自定义的 reducer 函数和初始的状态值
- 4. 在 reducer 函数中调用到了 useState 这个钩子函数

:::

```jsx title="第一步, 使用useState获取到用户传递的初始状态值"
const [state, setState] = useState(initialState);
```

```jsx title="第二步, 通过setState执行用户dispatch过来的action"
const dispatch = (action) => {
  setState(reducer(state, action));
};
```

```jsx title="第三步, 返回一个数组数组的第一个参数是状态值，第二个状态值是设置这个状态的方法"
return [state, dispatch];
```

```js title="如何控制promise执行的并发数"
// promise在异步操作中经常遇到, 对多个并发异步过程的处理Promise自身有 Promise.all()
// Promise.allSettled() Promise.race()等, 但都没有对并发数量进行控制,

class Schedule {
  constructor(maxNum) {
    this.list = [];
    this.maxNum = maxNum;
    this.workingNum = 0;
  }

  add(promiseCreator) {
    this.list.push(promiseCreator);
  }

  start() {
    for (let index = 0; index < this.maxNum; index += 1) {
      this.doNext();
    }
  }

  doNext() {
    if (this.list.length && this.workingNum < this.maxNum) {
      this.workingNum += 1;
      const promise = this.list.shift();
      promise().then(() => {
        this.workingNum -= 1;
        this.doNext();
      });
    }
  }
}

const timeout = (time) =>
  new Promise((resolve) => {
    setTimeout(resolve, time);
  });

const shedule = new Schedule(2);

const addTask = (time, order) => {
  schedule.add(() =>
    timeout(time).then(() => {
      console.log(order);
    })
  );
};

addTask(1000, 1);
addTask(500, 2);
addTask(300, 3);
addTask(400, 4);

shedule.start();
```
