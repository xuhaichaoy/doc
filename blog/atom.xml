<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xuhaichaoy.github.io/doc/blog</id>
    <title>Chao Blog</title>
    <updated>2021-11-22T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xuhaichaoy.github.io/doc/blog"/>
    <subtitle>Chao Blog</subtitle>
    <icon>https://xuhaichaoy.github.io/doc/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Algorithm]]></title>
        <id>Algorithm</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/2021/11/22/Algorithm"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js" metastring="title=&quot;节流&quot;" title="&quot;节流&quot;">function throttle(fn, time = 300) {
  // 先点击生效
  let flag = false;
  return function () {
    if (flag) {
      return;
    }
    flag = true;
    setTimeout(() =&gt; {
      fn.call(this, arguments);
      flag = false;
    }, time);
  };
}
</code></pre><pre><code class="language-js" metastring="title=&quot;防抖&quot;" title="&quot;防抖&quot;">function debounce(fn, time = 300) {
  // 后执行
  let timer;
  return function () {
    timer &amp;&amp; clearTimeout(timer);
    timer = setTimeout(() =&gt; {
      fn.call(this, arguments);
    }, time);
  };
}
</code></pre><pre><code class="language-js" metastring="title=&quot;深拷贝&quot;" title="&quot;深拷贝&quot;">function clone(target, map = new Map()) {
  if (typeof target === &quot;object&quot;) {
    let obj = Array.isArray(target) ? [] : {};

    if (map.get(target)) {
      return map.get(target);
    }

    map.set(target, obj);

    for (const key in target) {
      obj[key] = clone(target[key], map);
    }
    return obj;
  } else {
    return target;
  }
}
</code></pre><pre><code class="language-js" metastring="title=&quot;三数之和&quot;" title="&quot;三数之和&quot;">function threeSum(nums) {
  nums = [-1, 0, 1, 2, -1, -4];
  let res = [];
  nums.sort((a, b) =&gt; a - b);
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] === nums[i - 1]) continue;

    let left = i + 1;
    let right = nums.length - 1;
    let target = -nums[i];

    while (left &lt; right) {
      if (nums[left] + nums[right] === target) {
        res.push([nums[left], -target, nums[right]]);
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        left++;
        right--;
      } else if (nums[left] + nums[right] &gt; target) {
        right--;
      } else {
        left++;
      }
    }
  }

  return res;
}
</code></pre><pre><code class="language-js" metastring="title=&quot;三数之和 closest&quot;" title="&quot;三数之和">function threeSumClosest(nums, target) {
  let res = 0;
  let min = Number.MAX_VALUE;
  nums.sort((a, b) =&gt; a - b);
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] === nums[i - 1]) continue;

    let left = i + 1;
    let right = nums.length - 1;
    let current = nums[i];
    let dist = 0;

    while (left &lt; right) {
      let sum = nums[left] + nums[right] + current;
      dist = Math.abs(sum - target);

      if (dist === 0) {
        return target;
      } else if (sum &gt; target) {
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        right--;
      } else {
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        left++;
      }

      if (min &gt; dist) {
        min = dist;
        res = sum;
      }
    }
  }
  return res;
}
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Interview]]></title>
        <id>Interview</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/2021/11/22/Interview"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[浏览器从输入 url 到渲染页面，发生了什么]]></summary>
        <content type="html"><![CDATA[<h2>浏览器从输入 url 到渲染页面，发生了什么</h2><ol><li><p>首先解析域名，利用 dns 服务器解析域名成 ip</p><ul><li><p>域名为什么要解析？</p><ul><li><p>首先域名只能是 字母+数字+一些特殊符号（就是不包含百分号、双引号）不转义会出歧义 ke=y=1</p></li><li><p>Utf-8 编码</p></li><li><p>encodeURL encodeURLComponent 编码</p></li></ul></li><li><p>dns 如何工作？</p><ul><li>首先会从本机的 hosts 文件查找，查找到返回，</li><li>然后从本机配置的 dns 服务器缓存查找</li><li>然后从根 DNS 服务器查找（全球 13 台）</li><li>然后试图解析.baidu.com 直到能解析</li></ul></li><li><p>前端 dns 优化</p><ul><li>html 页面头部写入 dns 缓存地址</li></ul></li></ul></li><li><p>拿到 ip 以后，建立 TCP 链接（三次握手以及后面的四次分手）</p><ul><li>为什么是三次两次不行？<ul><li>两次可能会出现 A =&gt; B，B 未收到，A 又发送给 B</li><li>A=&gt;B，A 未收到</li></ul></li><li>第一次握手：A 发送位码 SYN=1TCP 包给服务器，并且随机产生一个确认号，主机 B 收到 SYN 码知道 A 要建立连接</li><li>第二次握手：B 收到请求以后，向 A 发送确认号（主机 A 的确认码+1），SYN=1，SEQ=随机数的包</li><li>第三次握手：A 收到确认号检查是否正确，是否是第一次发送值+1，以及位码是否为 1，如果正确，A 会再次发送主机 B SEQ+1，ack=1 给 B，主机 B 收到以后建立成功</li></ul></li><li><p>然后是强缓存，协商缓存</p><ul><li>强缓存，cache-control：no-cache 直接进入协商缓存，如果在时间内命中强缓存，不发送请求直接本地缓存读取文件， 如果没有 cache-control 会读取 expires 对比是否过期</li><li>协商缓存，向服务器发送 if-None-match 和 if-modify-since 请求，服务器会比较 etag，相同，协商缓存，304；不一致，新资源+200+新的 etag</li></ul></li><li><p>拿到 html css js</p><ol><li>构建 DOM 树</li><li>构建 CSSOM 树</li><li>执行 JS</li><li>构建渲染树</li><li>渲染树</li><li>布局</li><li>绘制</li></ol></li><li><p>页面渲染优化</p></li></ol><h2>Vue 和 React 对比</h2><p><strong>Vue</strong> 的思想是响应式的，也就是基于数据可变，通过对每一个属性建立 Watcher 来监听，当属性发生变化的时候，响应式的更新对应的虚拟 DOM</p><p><strong>React</strong> 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流</p><p>监听数据变化实现原理：</p><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 通过比较引用的方式进行，如果不优化（PureCompont/shouldComponentUpdate）可能会导致大量不必要的 VDOM 重新渲染</li></ul><p>组件通信区别： jsx 和.vue 模版</p><ul><li>HOC 和 Mixins（Vue 中组合不用功能通过 mixin），React 通过高阶组件</li></ul><p>性能优化：</p><ul><li>React：shouldComponentUpdate</li><li>Vue：内部实现 shouldComponentUpdate 优化，由于依赖追踪系统，通过 watcher 判断是否需要重新渲染（页面数据量大时，性能较差）</li></ul><h2>Vuex 和 Redux 区别</h2><p><strong>Redux</strong> 使用的是不可变数据，<strong>Vuex</strong> 是可变的，每次都用新的 state 替换旧的，vuex 是直接修改</p><p>Redux 监测数据变化是通过 diff 比较差异，Vuex 原理与 vue 相同，通过 getter/setter 比较</p><h2>webpack</h2><p><strong>Plugin/Loader 区别</strong></p><p>:::note 区别</p><ul><li>Loader 是加载器 Webpack 将⼀切⽂件视为模块，但是 Webpack 原⽣是只能解析 JavaScript ⽂件，如果想将其他⽂件也打包的话，就会⽤到 Loader。 所以 Loader 的作⽤是让 Webpack 拥有了加载和解析非 JavaScript 文件的能力;</li><li>Plugin 是插件 Plugin 可以扩展 Webpack 的功能,让 Webpack 具有灵活性。在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p>:::</p><p><strong>WebPack 中 bundle,chunk,module 的作用是什么</strong>
:::note 区别</p><ul><li>bundle 是由 Webpack 打包出来的文件;</li><li>chunk 代码块,一个 chunk 由多个模块组合⽽成，⽤于代码的合并和分割;</li><li>module 是开发中的单个模块，在 Webpack 中⼀个模块对应⼀个⽂件，Webpack 会从配置的 entry 中递归开始找出所有依赖的模块。</li></ul><p>:::</p><p><strong>setState 是同步还是异步的</strong></p><ul><li>如果是正常的情况下，也就是没有使用 Concurrent 组件，是同步更新的，但是不会立即获得最新的 state 值。因为调用 setState 只是单纯的将最新的状态放到 updateQueue 链表上，等这个点击事件（合成事件）结束后会触发一个回调函数，在这个回调函数中才会更新 state，以及重新渲染。</li><li>当使用了 Concurrent 组件的时候，才是真正的异步更新模式。同样没法立即获得最新状态，并且在执行 React 更新和渲染的过程中，使用了真正的异步方式（postMessage）会放到 eventloop 中</li><li>当使用了 flushSync 这个 api 的时候，React 更新渲染是完全同步的，会立即触发更新和渲染操作，可以获取到最新的状态</li></ul><pre><code class="language-jsx"> flushSync(() =&gt; {
   this.setState({
     data: &#x27;xxx&#x27;
   })
 })

 &lt;Concurrent&gt;
   &lt;h1&gt;xxx&lt;/h1&gt;
 &lt;/Concurrent&gt;
</code></pre><p><strong>想立即获取 state 值</strong></p><ul><li>flushSync</li><li>addEventListener</li><li>serRimeout(() =&gt; {})</li></ul><h2>ES moudle 和 CommonJS 区别 todo</h2><ul><li><p>CommonJS 是对模块的浅拷贝，ES6 Moundle 是对模块的引用，即 ES6 Moudle 只存不读，不能改变其值，也就是指针指向不变，类似 const</p></li><li><p>import 的接口是 read-only（只读状态），不能修改变量值，不能改变指针指</p><p>向</p></li></ul><h2>useCallback UseMemo Memo 区别</h2><ul><li>React.memo 包裹以后，子组件只在 props 发生变化以后才会重新渲染。</li><li>useCallback 可以对函数缓存，父组件给子组件传值（值为函数 handleClick），由于 handleClick 是一个对象，每次重新渲染生成的 handleClick 都是新的，所以子组件依旧会渲染，这时候只能通过 useCallback 包裹</li><li>如果传递给自组建一个对象{a:1,b:2} 这时候需要使用 useMemo</li></ul><h2>HTTP 协议</h2><p><strong>Get 和 Post 请求的区别</strong></p><ul><li>应用场景: Get 请求一般用来获取数据, 一般 Get 请求用于对服务器资源不会产生影响; Post 请求一般用于对服务器产生影响的情景.</li><li>是否缓存: 浏览器一般会对 Get 请求缓存, 但很少对 Post 缓存</li><li>发送的报文格式: get 请求实体部分为空, post 为数据</li><li>安全性: get 请求会将参数拼接到 url 上, 相对于 post 不安全, 会被历史记录保留</li><li>请求长度: url 长度会被限制</li><li>参数类型: post 请求支持更多数据类型</li></ul><p><strong>HTTP1.0 和 HTTP1.1 区别</strong></p><ul><li>连接方面: http1.0 默认非持久连接, http1.1 持久连接. http1.1 通过持久连接使多个 http 复用同一个 TCP 连接, 避免建立连接时延.</li><li>资源请求方面: 1.0 不支持断点续传, 服务端发送完整对象. 1.1 加入了 range, 允许只请求部分资源,返回码 206</li><li>缓存方面: 1.0 使用 header if_modified-since、Expires 做为缓存标准. 1.1 使用 Etag、if-Match、if-None-Match 缓存头控制</li><li>1.1 新增 host 字段, 指定服务器域名. 1.0 认为每台服务器都绑定唯一 ip, 因此并没有传递主机名.</li><li>1.1 新增许多请求方法, put head options</li></ul><p><strong>Http1.1 和 Http2.0 区别</strong></p><ul><li>二进制协议 1.1 文本 + 二进制; 2.0 纯二进制</li><li>多路复用 仍复用 TCP 连接, 在同一个连接内, 客户端服务器都可以同时发送多个请求或回应, 不用按照顺序, 避免了队头阻塞</li><li>数据流 2.0 采用数据流, 数据包不按顺序发送, 数据包发送的时候必须标记数据流 ID</li><li>头信息压缩 1.1 协议不带状态, 每次请求必须携带所有信息, 2.0 头信息压缩 gzip/compress 压缩后发送; 另一方面客户端和服务器维护一个头信息表,所有字段存入,生成索引号,不发送相同字段</li><li>服务器推送 2.0 允许服务器主动向客户端发送资源. 提前给客户端推送必要资源.</li></ul><p>:::tip 队头阻塞
队头阻塞是由 http 规定报文必须是一发一收,这就是一个串行队列, 请求没有优先级, 只有入队顺序.
:::</p><p><strong>Https 和 Http 区别</strong></p><ul><li>https 需要 CA 证书, 费用较高</li><li>http 是超文本传输协议, 明文传输, https 是 SSL 加密传输协议</li><li>http 80 端口 https 443</li><li>http 连接无状态; https 有 SSL 加密传输, 身份验证 更安全</li></ul><p><strong>多张图片, 加载</strong></p><ul><li>1 下, 浏览器对一个域名下最大 TCP 连接为 6, 会请求多次. 可以通过多域名部署解决.加快速度</li><li>2 下, 瞬间加载多个资源, 多路复用, 可以发送多个请求</li></ul><p><strong>HTTP 协议的优点和缺点</strong></p><ul><li>简单快速</li><li>无连接</li><li>无状态</li><li>灵活</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nuxt]]></title>
        <id>Nuxt</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/2021/11/22/Nuxt"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[项目技术 nuxt, composition-api]]></summary>
        <content type="html"><![CDATA[<p><strong>项目技术 nuxt, composition-api</strong>
<a href="https://m.66rpg.com/mini">M 站地址</a></p><p>:::tip 前言
为什么采用 composition-api, 因为 composition-api 是 Vue 下一个版本最常用的语法,一个全新的逻辑重用和代码组织方法.</p><p>代码更易读, 写法更舒服.
:::</p><p>目标是为了开发方便并且便于生产环境测试用</p><ul><li>本地 test debug main 环境</li><li>生产环境 test debug main 环境</li></ul><p>需要区分环境, 所以引入 cross-env 插件, 可以在启动/构建项目的时候设置环境</p><p>根据不同的环境设置不同 prefix,从而走不同的反代</p><p>:::caution 坑点</p><ul><li>反代 target 地址需要自定义, 由于地址需要根据当前分支,主域名去设置, 所以用到了 router 可以设置为函数, 里面可以拿到 headers</li><li>生产环境的 build start 都需要设置环境参数</li></ul><p>解决方案:</p><pre><code class="language-js" metastring="title=&quot;nuxt.config.js&quot;" title="&quot;nuxt.config.js&quot;">
 axios: {
    proxy: true,
    prefix:
      process.env.NODE_ENV === &#x27;dev&#x27;
        ? &#x27;/test&#x27;
        : &#x27;&#x27;,
    credentials: true,
  },

  proxy: {
    &#x27;/test&#x27;: {
      target: &#x27;http://test-www.66rpg.com&#x27;,
      ws: true,
      pathRewrite: {
        &#x27;^/test&#x27;: &#x27;/&#x27;,
        changeOrigin: true,
      },
      router({ headers }) {
        return (
          &#x27;http://&#x27; +
          branch +
          (headers.domain ? headers.domain : &#x27;www&#x27;) +
          &#x27;.66rpg.com/&#x27;
        )
      },
    },
  },

// package.json
&quot;dev&quot;: &quot;cross-env NODE_ENV=dev nuxt&quot;,
&quot;build:test&quot;: &quot;cross-env NODE_ENV=dev nuxt build&quot;,
&quot;start:test&quot;: &quot;cross-env NODE_ENV=dev nuxt start&quot;,
</code></pre><p>:::
<strong>由于后端原因需要跟目前站上区分开 所以需要设置一个 前缀参数 /mini 目标是 host + &#x27;xxx&#x27; + 路由</strong></p><p>:::caution 坑点</p><ul><li>理想情况是设置了 base 以后, 访问 / 会自动重定向到 /mini, 不过这一步 nuxt 官方并没有做, 而是提供了一个 hook 方案, 拿到 response 然后重定向</li><li>hook 方案会和 proxy 冲突,需要手动修改</li></ul><p>解决方案:</p><pre><code class="language-js" metastring="title=&quot;nuxt.config.js&quot;" title="&quot;nuxt.config.js&quot;">router: {
  base: &quot;/mini&quot;;
}

hooks: hooks(this); // 官网写法 这样写有问题
</code></pre><pre><code class="language-js" metastring="title=&quot;hook/route-redirec-portal.js&quot;" title="&quot;hook/route-redirec-portal.js&quot;">function projectHooksRouteRedirectPortal(req, res, next) {
  if (pathname === &quot;/&quot;) {
    res.writeHead(302, {
      Location,
    });
    res.end();
  }
  next();
}
</code></pre><pre><code class="language-js" metastring="title=&quot;nuxt.config.js&quot;" title="&quot;nuxt.config.js&quot;">// 解决方案
const config = {
  router: {
    base: &quot;/mini&quot;,
  },
};
config.hooks = hooks(config);

export default config;
</code></pre><p>:::</p><h4>组件传参:</h4><ul><li><p>props/emit</p><pre><code class="language-javascript">props: {
    detail: {
      type: Object,
      required: true,
    },
    activedata: {
      type: Object,
      required: true,
    },
  },
</code></pre></li><li><p>provide/inject 定义一个对象传给 provide 就是响应式</p></li><li><p>vuex</p></li></ul><h4>首页加载优化:</h4><ul><li>plugins 慎重写, 插件按需加载, 一些模块如: swiper 可以在 client 加载,element-ui 设置按需加载</li><li>首屏数据,如果是服务器端渲染,需要 异步并行发送接口,同时请求数据 Promise.all</li><li>组件懒加载(用了迅雷团队的插件 vue-lazy-component)</li><li>swiper 图片懒加载,图片设置 webp 压缩</li><li>v-if 一些首屏未展示模块设置 v-if</li><li>build 设置 gzip</li></ul><p>:::caution 坑点/解决方案:</p><ul><li>由于 element-ui 需要设置主题色, 需要每个组件的样式单独引入</li><li>ios webp 支持不好, 需要判断平台走不同的压缩</li></ul><p>:::</p><p><strong>由于使用了 composition-api 写法 nuxt 使用问题</strong></p><ul><li>获取参数 可以通过 useContext</li><li>服务器端请求 使用 useFetch</li></ul><p><strong>需要在全局任一位置请求用户信息接口,并且存储到 store 中</strong></p><pre><code class="language-js" metastring="title=&quot;middleware/redirect.js&quot;" title="&quot;middleware/redirect.js&quot;">
router: {
  middleware: &#x27;redirect&#x27;,
},

export default async ({ isHMR, store }) =&gt; {
  if (isHMR) return
  if (!store.state.userInfos.uid) {
    const { status, data } = await getUserInfo()
    if (status === 1) {
      getBasketflower()
      store.commit(&#x27;setUserInfo&#x27;, data.userInfos)
    } else {
      store.commit(&#x27;delUserInfo&#x27;)
    }
  }
}
</code></pre><p><strong>路由访问的时候, 当访问错误路由需要跳转到首页路由</strong></p><pre><code class="language-javascript">router: {
    extendRoutes(routes, resolve) {
        routes.push({
            name: &#x27;default&#x27;,
            path: &#x27;*&#x27;,
            component: resolve(__dirname, &#x27;pages/home&#x27;),
        })
    },
},
</code></pre><p>:::caution 需要注意的点:</p><ol><li>ios safari 浏览器 默认屏蔽 window.open 写一个 a 标签触发 a</li><li>swiper 在 nuxt 使用的时候 需要将 swiper 设置为 client, ssr:false, 并且 swiper 需要用 client-only 包裹</li><li>props 传参不能用解构赋值, 需要用 watch 监听 props.xxx ,否则数据不会变化</li></ol><p>:::
<strong>兼容性处理 browserslist</strong></p><p><strong>节流防抖</strong></p><p><strong>设置启动端口(配合运维做平滑启动)</strong></p><pre><code class="language-javascript"> // package.json
 &quot;config&quot;: {
    &quot;nuxt&quot;: {
      &quot;host&quot;: &quot;0.0.0.0&quot;,
      &quot;port&quot;: &quot;3000&quot;
    }
  },
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>welcome</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/welcome"/>
        <updated>2021-08-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Docusaurus blogging features are powered by the blog plugin.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://docusaurus.io/docs/blog">Docusaurus blogging features</a> are powered by the <a href="https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog">blog plugin</a>.</p><p>Simply add Markdown files (or folders) to the <code>blog</code> directory.</p><p>Regular blog authors can be added to <code>authors.yml</code>.</p><p>The blog post date can be extracted from filenames, such as:</p><ul><li><code>2019-05-30-welcome.md</code></li><li><code>2019-05-30-welcome/index.md</code></li></ul><p>A blog post folder can be convenient to co-locate blog post images:</p><p><img src="./docusaurus-plushie-banner.jpeg" alt="Docusaurus Plushie"/></p><p>The blog supports tags as well!</p><p><strong>And if you don&#x27;t want a blog</strong>: just delete this directory, and use <code>blog: false</code> in your Docusaurus config.</p>]]></content>
        <author>
            <name>Sébastien Lorber</name>
            <uri>https://sebastienlorber.com</uri>
        </author>
        <author>
            <name>Yangshun Tay</name>
            <uri>https://github.com/yangshun</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[MDX Blog Post]]></title>
        <id>mdx-blog-post</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/mdx-blog-post"/>
        <updated>2021-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Blog posts support Docusaurus Markdown features, such as MDX.]]></summary>
        <content type="html"><![CDATA[<p>Blog posts support <a href="https://docusaurus.io/docs/markdown-features">Docusaurus Markdown features</a>, such as <a href="https://mdxjs.com/">MDX</a>.</p><p>:::tip</p><p>Use the power of React to create interactive blog posts.</p><pre><code class="language-js">&lt;button onClick={() =&gt; alert(&#x27;button clicked!&#x27;)}&gt;Click me!&lt;/button&gt;
</code></pre><button>Click me!</button><p>:::</p>]]></content>
        <author>
            <name>Sébastien Lorber</name>
            <uri>https://sebastienlorber.com</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Long Blog Post]]></title>
        <id>long-blog-post</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/long-blog-post"/>
        <updated>2019-05-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is the summary of a very long blog post,]]></summary>
        <content type="html"><![CDATA[<p>This is the summary of a very long blog post,</p><p>Use a <code>&lt;!--</code> <code>truncate</code> <code>--&gt;</code> comment to limit blog post size in the list view.</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p>]]></content>
        <author>
            <name>Endilie Yacop Sucipto</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[First Blog Post]]></title>
        <id>first-blog-post</id>
        <link href="https://xuhaichaoy.github.io/doc/blog/first-blog-post"/>
        <updated>2019-05-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet]]></summary>
        <content type="html"><![CDATA[<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p>]]></content>
        <author>
            <name>Gao Wei</name>
            <uri>https://github.com/wgao19</uri>
        </author>
    </entry>
</feed>