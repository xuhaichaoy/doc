# Interview

## 浏览器从输入 url 到渲染页面，发生了什么

1. 首先解析域名，利用 dns 服务器解析域名成 ip

   - 域名为什么要解析？

     - 首先域名只能是 字母+数字+一些特殊符号（就是不包含百分号、双引号）不转义会出歧义 ke=y=1

     - Utf-8 编码
     - encodeURL encodeURLComponent 编码

   - dns 如何工作？

     - 首先会从本机的 hosts 文件查找，查找到返回，
     - 然后从本机配置的 dns 服务器缓存查找
     - 然后从根 DNS 服务器查找（全球 13 台）
     - 然后试图解析.66rpg.com 直到能解析

   - 前端 dns 优化

     - html 页面头部写入 dns 缓存地址

2. 拿到 ip 以后，建立 TCP 链接（三次握手以及后面的四次分手）

   - 为什么是三次两次不行？
     - 两次可能会出现 A => B，B 未收到，A 又发送给 B
     - A=>B，A 未收到
   - 第一次握手：A 发送位码 SYN=1TCP 包给服务器，并且随机产生一个确认号，主机 B 收到 SYN 码知道 A 要建立连接
   - 第二次握手：B 收到请求以后，向 A 发送确认号（主机 A 的确认码+1），SYN=1，SEQ=随机数的包
   - 第三次握手：A 收到确认号检查是否正确，是否是第一次发送值+1，以及位码是否为 1，如果正确，A 会再次发送主机 B SEQ+1，ack=1 给 B，主机 B 收到以后建立成功

3. 然后是强缓存，协商缓存

   - 强缓存，cache-control：no-cache 直接进入协商缓存，如果在时间内命中强缓存，不发送请求直接本地缓存读取文件， 如果没有 cache-control 会读取 expires 对比是否过期
   - 协商缓存，向服务器发送 if-None-match 和 if-modify-since 请求，服务器会比较 etag，相同，协商缓存，304；不一致，新资源+200+新的 etag

4. 拿到 html css js
   1. 构建 DOM 树
   2. 构建 CSSOM 树
   3. 执行 JS
   4. 构建渲染树
   5. 渲染树
   6. 布局
   7. 绘制
5. 页面渲染优化

## Vue 和 React 对比

**Vue** 的思想是响应式的，也就是基于数据可变，通过对每一个属性建立 Watcher 来监听，当属性发生变化的时候，响应式的更新对应的虚拟 DOM

**React** 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流

监听数据变化实现原理：

- Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能
- React 通过比较引用的方式进行，如果不优化（PureCompont/shouldComponentUpdate）可能会导致大量不必要的 VDOM 重新渲染

组件通信区别： jsx 和.vue 模版

- HOC 和 Mixins（Vue 中组合不用功能通过 mixin），React 通过高阶组件

性能优化：

- React：shouldComponentUpdate
- Vue：内部实现 shouldComponentUpdate 优化，由于依赖追踪系统，通过 watcher 判断是否需要重新渲染（页面数据量大时，性能较差）

## Vuex 和 Redux 区别

**Redux** 使用的是不可变数据，**Vuex** 是可变的，每次都用新的 state 替换旧的，vuex 是直接修改

Redux 监测数据变化是通过 diff 比较差异，Vuex 原理与 vue 相同，通过 getter/setter 比较

## webpack

**Plugin/Loader 区别**

:::note 区别

- Loader 是加载器 Webpack 将⼀切⽂件视为模块，但是 Webpack 原⽣是只能解析 JavaScript ⽂件，如果想将其他⽂件也打包的话，就会⽤到 Loader。 所以 Loader 的作⽤是让 Webpack 拥有了加载和解析非 JavaScript 文件的能力;
- Plugin 是插件 Plugin 可以扩展 Webpack 的功能,让 Webpack 具有灵活性。在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

:::

**WebPack 中 bundle,chunk,module 的作用是什么**
:::note 区别

- bundle 是由 Webpack 打包出来的文件;
- chunk 代码块,一个 chunk 由多个模块组合⽽成，⽤于代码的合并和分割;
- module 是开发中的单个模块，在 Webpack 中⼀个模块对应⼀个⽂件，Webpack 会从配置的 entry 中递归开始找出所有依赖的模块。

:::

## ES moudle 和 CommonJS 区别

## UseCallback UseMemo Memo 区别

## HTTP 协议

**Get 和 Post 请求的区别**

- 应用场景: Get 请求一般用来获取数据, 一般 Get 请求用于对服务器资源不会产生影响; Post 请求一般用于对服务器产生影响的情景.
- 是否缓存: 浏览器一般会对 Get 请求缓存, 但很少对 Post 缓存
- 发送的报文格式: get 请求实体部分为空, post 为数据
- 安全性: get 请求会将参数拼接到 url 上, 相对于 post 不安全, 会被历史记录保留
- 请求长度: url 长度会被限制
- 参数类型: post 请求支持更多数据类型

**HTTP1.0 和 HTTP1.1 区别**

- 连接方面: http1.0 默认非持久连接, http1.1 持久连接. http1.1 通过持久连接使多个 http 复用同一个 TCP 连接, 避免建立连接时延.
- 资源请求方面: 1.0 不支持断点续传, 服务端发送完整对象. 1.1 加入了 range, 允许只请求部分资源,返回码 206
- 缓存方面: 1.0 使用 header if_modified-since、Expires 做为缓存标准. 1.1 使用 Etag、if-Match、if-None-Match 缓存头控制
- 1.1 新增 host 字段, 指定服务器域名. 1.0 认为每台服务器都绑定唯一 ip, 因此并没有传递主机名.
- 1.1 新增许多请求方法, put head options

**Http1.1 和 Http2.0 区别**

- 二进制协议 1.1 文本 + 二进制; 2.0 纯二进制
- 多路复用 仍复用 TCP 连接, 在同一个连接内, 客户端服务器都可以同时发送多个请求或回应, 不用按照顺序, 避免了队头阻塞
- 数据流 2.0 采用数据流, 数据包不按顺序发送, 数据包发送的时候必须标记数据流 ID
- 头信息压缩 1.1 协议不带状态, 每次请求必须携带所有信息, 2.0 头信息压缩 gzip/compress 压缩后发送; 另一方面客户端和服务器维护一个头信息表,所有字段存入,生成索引号,不发送相同字段
- 服务器推送 2.0允许服务器主动向客户端发送资源. 提前给客户端推送必要资源.

:::tip 队头阻塞
  队头阻塞是由 http规定报文必须是一发一收,这就是一个串行队列, 请求没有优先级, 只有入队顺序.
:::

**Https和Http区别**
- https需要CA证书, 费用较高
- http是超文本传输协议, 明文传输, https是SSL加密传输协议
- http 80端口 https 443
- http 连接无状态; https有SSL 加密传输, 身份验证 更安全

**多张图片, 加载**
- 1下, 浏览器对一个域名下最大TCP连接为6, 会请求多次. 可以通过多域名部署解决.加快速度
- 2下, 瞬间加载多个资源, 多路复用, 可以发送多个请求

**HTTP协议的优点和缺点**
- 简单快速
- 无连接
- 无状态
- 灵活