### 什么是原子化 CSS?

:::tip
原子化 CSS 是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。
:::

有些人可能会称其为函数式 CSS，或者 CSS 实用工具。
本质上，你可以将原子化的 CSS 框架理解为这类 CSS 的统称：

```css
.m-0 {
  margin: 0;
}
.text-red {
  color: red;
}

```

Windi CSS 是从零开始编写的 Tailwind CSS 的替代方案。
它的零依赖，也不要求用户安装 PostCSS 和 Autoprefixer。
更为重要的是，它支持 按需生成。
Windi CSS 不会一次生成所有的 CSS，而是只会生成你在代码中实际使用到的原子化 CSS。

### 剖析原子化 CSS

#### 传统方案

制作原子化 CSS 的传统方案其实就是提供所有你可能需要用到的 CSS 工具。
例如，你可能会用预处理器（这里选用的是 SCSS）生成如下代码：

```scss
// style.scss

@for $i from 1 through 10 {
  .m-#{$i} {
    margin: $i / 4 rem;
  }
}
```

编译结果： 

```scss
.m-1 { margin: 0.25 rem; }
.m-2 { margin: 0.5 rem; }
/* ... */
.m-10 { margin: 2.5 rem; }

```

**现在你可以直接使用 class="m-1" 来设置边距。**

但正如你所见，用这种方法的情况下，你不能使用除了 1 到 10 之外的边距，
而且，即使你只使用了其中一条 CSS 规则，但还是要为其余几条规则的文件体积买单。


如果之后你还想支持不同的 margin 方向，使用比如 mt 代表 margin-top，
mb 代表 margin-bottom 等，加上这 4 个方向以后，
你的 CSS 大小会变成原来的 5 倍。


如果再有使用到像 :hover 和 :focus 这样的伪类时，
体积还会得更变大。以此类推，每多加一个工具类，往往意味着你 CSS 文件的大小也会随之增加。
这也就是为什么传统的 Tailwind 生成的 CSS 文件会有数 MB 的大小。


为了解决这个问题，Tailwind 通过使用 [PurgeCSS](https://www.purgecss.cn/) 来扫描你的大包产物并删除你不需要的规则。
这得以使其在生产环境中 CSS 文件缩减为几 KB。
然而，请注意，这个清除操作仅在生成构建下有效，而开发环境下仍要使用包含了所有规则巨大的 CSS 文件。
这在 Webpack 中表现可能并不明显，但在 Vite 中却有着巨大的影响，毕竟其他内容的加载都非常迅捷。

**既然生成再清除的方法存在局限性，那是否有更好的解决方案？**

#### 按需生成

"按需生成" 的想法引入了一种全新的思维方式。让我们先来对比下这些方案：




