## useEffect && useLayoutEffect

用法一致, 如果不传第二个参数, 只要该组件有 `state` 改变就会触发一次回调, 用 return 返回一个函数, 组件每次重新渲染都会先执行该函数
区别:

- `useEffect` 是异步调用 页面渲染后执行
- `useLayoutEffect` 是同步调用 页面渲染前执行.

## PureComponent

`PureComponent` 会浅比较, `props` 和 `state`是否相同, 来决定是否重新渲染组件, 所以一般用于性能调优,减少 render 次数

## memo

`React.memo` 和 `PureComponent` 作用类似, 可以做性能优化, `React.memo`是高阶组件, 函数组件和类组件都能使用

区别是:

- `React.memo` 只能对 `props`情况确定是否渲染,
- `PureComponent` 是针对 `props` 和 `state`

memo 第二个参数 返回 true 组件不渲染, false 渲染
shouldComponentUpdate 返回 true 渲染 false 不渲染

## useCallback UseMemo Memo 区别

- React.memo 包裹以后，子组件只在 props 发生变化以后才会重新渲染。
- useCallback 可以对函数缓存，父组件给子组件传值（值为函数 handleClick），由于 handleClick 是一个对象，每次重新渲染生成的 handleClick 都是新的，所以子组件依旧会渲染，这时候只能通过 useCallback 包裹
- 如果传递给自组建一个对象{a:1,b:2} 这时候需要使用 useMemo

## setState 是同步还是异步的

- 如果是正常的情况下，也就是没有使用 Concurrent 组件，是同步更新的，但是不会立即获得最新的 state 值。因为调用 setState 只是单纯的将最新的状态放到 updateQueue 链表上，等这个点击事件（合成事件）结束后会触发一个回调函数，在这个回调函数中才会更新 state，以及重新渲染。
- 当使用了 Concurrent 组件的时候，才是真正的异步更新模式。同样没法立即获得最新状态，并且在执行 React 更新和渲染的过程中，使用了真正的异步方式（postMessage）会放到 eventloop 中
- 当使用了 flushSync 这个 api 的时候，React 更新渲染是完全同步的，会立即触发更新和渲染操作，可以获取到最新的状态

```jsx
 flushSync(() => {
   this.setState({
     data: 'xxx'
   })
 })

 <Concurrent>
   <h1>xxx</h1>
 </Concurrent>
```

## 想立即获取 state 值

- flushSync
- addEventListener
- serRimeout(() => {})

## 如何理解单向数据流

- 什么是数据流?
- 为什么是自上而下的
- 单向数据流是什么意思?
- 为什么是单向的? 不能是双向的数据流?
- 单向数据流有什么作用?

数据流就是指数据在组件间的传递, 组件间的值传递.
单向数据流是什么意思? 就是某个节点被改变后, 只会影响一个方向上的其它节点.
自上而下是什么意思? 数据变动只会影响下一个层级的节点, 不会影响上一个层级的节点.

单向数据流: 规范的数据流向, 数据由外层组件向内层组件进行传递和更新

## 受控组件和非受控组件区别

我们对某个组件状态的掌控, 他的值是否只能由用户设置, 而不能通过代码控制.

在 React 中, 所谓受控组件和非受控组件, 是针对表单而言的.

表单受控组件

- 表单元素依赖状态, 表单元素需要默认值实时映射到状态的时候, 就是受控组件, 这个和双向绑定相似.
- 受控组件, 表单元素的修改会实时映射到状态值上, 此时就可以对输入的内容进行校验.
- 受控组件只有继承 `React.Component` 才会有状态
- 受控组件必须要在表单上使用 `onChange` 事件来绑定对应的事件

非受控组件

- 非受控组件即不受状态的控制, 获取数据就是相当于操作 DOM
- 非受控组件的好处是很容易和第三方组件结合

## React 函数组件的 re-render 原理和优化

对于函数组件的 re-render, 分为三种情况

- 组件本身使用 `useState` 或 `useReducer` 更新, 引起的 re-render;
- 父组件更新引起的 re-render
- 组件本身是用了 `useContent`, `context` 更新引起的 re-render

### 1. 组件本身使用 useState 或 useReducer 更新, 引起的 re-render

#### 1.1 常规使用

以计数组件为例, 如下每次点击 add, 都会打印 `counter render`, 表示引起了 re-render;

```jsx
const Counter = () => {
  console.log("counter render");
  const [count, addCount] = useState(0);
  return (
    <div>
      <div>{count}</div>
      <button onClick={() => addCount(count + 1)}>add</button>
    </div>
  );
};
```

#### 1.2 immutation state

下面我们将计数组件中的 state 改成引用类型, 如下, 发现并不会引起 re-render;

```jsx
const Counter = () => {
  console.log("counter render");
  const [count, addCount] = useState({ num: 0, time: Date.now() });
  const clickHandler = () => {
    count.num++;
    count.time = Date.now();
    addCount(count);
  };

  return (
    <div>
      <div>
        {count.num} {count.time}
      </div>
      <button onClick={clickHandler}>add</button>
    </div>
  );
};
```

原因在于, 更新 state 的时候, 会有一个新老 state 的比较, 用的是 `Object.is` 进行比较, 如果为 true 则直接返回不更新,
源码如下(objectIs 会判断 `Object.is` 是否支持, 如果不支持则重新实现, eagerState 就是 oldState);

```js
if (objectIs(eagerState, currentState)) {
  return;
}
```

所以更新 state 时候要注意, state 为不可变数据, 每次更新都需要一个新值才会有效.

#### 1.3 强制更新

相比于类组件有个 `forceUpdate` 方法, 函数组件是没有该方法的, 但是其实也可以自己写一个, 如下, 由于 `Object.is({}, {})` 总是 `false`, 所以总能引起更新;

```jsx
const [, forceUpdate] = useState({});
forceUpdate({});
```

说完 `useState` 的更新, 其实 `useReducer` 就不用说了, 源码里 `useState` 的更新调用的就是 `useReducer` 的更新

```js
function updateState(initialState) {
  return updateReducer(basicStateReducer);
}
```
